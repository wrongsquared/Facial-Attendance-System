from typing import Union, List
from fastapi import FastAPI, Depends, HTTPException, status, APIRouter
from sqlalchemy import func, distinct, case, literal, and_
from fastapi.middleware.cors import CORSMiddleware 
from pydantic import BaseModel
from sqlalchemy import create_engine, text
from sqlalchemy.orm import sessionmaker, Session, joinedload
from database.db_config import get_db #Gets the Initialized db session
from database.db import (UserProfile, #This was really long so I had to bracket it
                         User, 
                         Lecturer, 
                         Student,
                         Admin)

from uuid import UUID
from pdantic.schemas import (UserSignUp, #This was really long so I had to bracket it
                             UserLogin, 
                             TokenResponse)
from dependencies.deps import get_current_user_id
from client import supabase, supabase_adm
import datetime
from routers import adminDashboardRouter, studentDashboardRouter, lecturerDashboardRouter 


app = FastAPI()

origins = [
    "http://localhost:3000",  # React Create App
]

app.add_middleware(
    CORSMiddleware,
    allow_origins= origins,
    allow_credentials = True,
    allow_methods=["*"],
    allow_headers=["*"]
)


@app.get("/")
def read_root(db: Session= Depends(get_db)):
    response = (supabase_adm.table("users").select("*").execute())
    return {"Message": response}

@app.post("/createAcc", status_code=status.HTTP_201_CREATED)
def register_user(user: UserSignUp, db: Session = Depends(get_db)):
    # Create User in Supabase Auth
    try:
        # This contacts Supabase Cloud to create the login
        auth_response = supabase_adm.auth.admin.create_user({
            "email": user.email,
            "password": user.password,
            # Optional: Add metadata so it lives in the JWT
            "options": {
                "data": {
                    "name": user.name,
                    "role": user.role
                }
            }
        })
        
        if not auth_response.user:
            raise HTTPException(status_code=400, detail="Signup failed (User already exists?)")
            
        # Capture the UUID generated by Supabase
        new_uuid = UUID(auth_response.user.id)

    except Exception as e:
        # Catch Supabase errors (like "Password too short" or "Email exists")
        raise HTTPException(status_code=400, detail=str(e))


    # Create Profile in Postgres
    try:
        new_db_user = None

        if user.role.lower() == "student":
            # Ensure course_id is provided for students
            if not user.course_id:
                raise HTTPException(status_code=400, detail="Student requires a course_id")

            new_db_user = Student(
                userID=new_uuid,  # LINKING THE UUID
                name=user.name,
                email=user.email,
                profileTypeID=user.profile_type_id,
                courseID=user.course_id,
                # Default values
                photo=None
            )
            
        elif user.role.lower() == "lecturer":
            new_db_user = Lecturer(
                userID=new_uuid, # <--- LINKING THE UUID
                name=user.name,
                email=user.email,
                profileTypeID=user.profile_type_id,
                photo=None
            )
        else:
            # If role is invalid, we have a problem. 
            # We created an Auth User but can't create a DB Profile.
            # We should technically delete the Auth User here to clean up.
            raise HTTPException(status_code=400, detail="Invalid Role")

        # Save to Database
        db.add(new_db_user)
        db.commit()
        db.refresh(new_db_user)

        return {"message": "User created successfully", "user_id": new_uuid}

    except Exception as e:
        # CRITICAL: If DB insert fails (e.g. Course ID doesn't exist), 
        # we have a "Ghost User" in Supabase Auth but no profile in DB.
        db.rollback()
        
        # Cleanup: Delete the Auth user so they can try again
        # Note: Requires Service Role Key to delete. If using Anon key, you can't cleanup easily.
        print(f"Database error: {e}") 
        raise HTTPException(status_code=500, detail="Profile creation failed. Please contact support.")

@app.delete("/delacc/{user_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_user(user_id: UUID, db: Session = Depends(get_db)):
    

    # Check if user exists in Public DB
    # We query the Base 'User' table because it covers Students, Lecturers, etc.
    user_to_delete = db.query(User).filter(User.userID == user_id).first()
    
    if not user_to_delete:
        raise HTTPException(status_code=404, detail="User not found in database")

    # Delete from Public Database (SQLAlchemy)
    try:
        db.delete(user_to_delete)
        db.commit()
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Failed to delete profile: {str(e)}")


    # Delete from Supabase Auth (Cloud)

    try:
        # returns an object with 'data' and 'error' (in older versions) 
        # or simply returns None/Data (in newer versions)
        response = supabase_adm.auth.admin.delete_user(str(user_id))
        
        # Note: If the user didn't exist in Auth (ghost user), this might throw an error 
        # or just work silently. We generally assume success if no exception raised.
        
    except Exception as e:
        # If Auth deletion fails, we have a problem: 
        # The profile is gone from DB, but the login remains.
        # Ideally, you should log this error heavily.
        print(f"CRITICAL: Profile deleted but Auth User {user_id} remains! Error: {e}")
        raise HTTPException(status_code=500, detail="Profile deleted, but Auth account cleanup failed.")

    return None

 #Student Login
@app.post("/login", response_model = TokenResponse)
def login(credentials:UserLogin, db:Session = Depends(get_db)):
    try:
        # This sends email/password to Supabase. 
        # If valid, Supabase returns a Session object with tokens.
        auth_response = supabase.auth.sign_in_with_password({
            "email": credentials.email,
            "password": credentials.password
        })
        session = auth_response.session
        user = auth_response.user
        
        if not session or not user:
             raise HTTPException(status_code=401, detail="Invalid credentials")
    except Exception as e:
        # Supabase throws an exception if password is wrong or email not confirmed
        raise HTTPException(status_code=401, detail=str(e))

    # Identify Role from Postgres DB
    
    user_uuid = user.id
    
    # Query the 'users' table to get the profileTypeID
    db_user = db.query(User).filter(User.userID == user_uuid).first()
    
    if not db_user:
        # This happens if they exist in Auth but were deleted from DB (Ghost User)
        raise HTTPException(status_code=404, detail="User profile not found in database.")

    # Optional: Fetch the text name of the role (e.g., "Student")
    # This requires a join or a separate query if lazy loading isn't set up
    role_name = "Unknown"
    profile_type = db.query(UserProfile).filter(UserProfile.profileTypeID == db_user.profileTypeID).first()
    if profile_type:
        role_name = profile_type.profileTypeName

    # Return the Bundle
    return {
        "access_token": session.access_token,
        "refresh_token": session.refresh_token,
        "token_type": "bearer",
        "user_id": user_uuid,
        "role_id": db_user.profileTypeID,
        "role_name": role_name
    }

@app.post("/logout", status_code=204)
def logout():
    """
    Logs out the user on the server side (invalidates refresh token).
    The Frontend MUST also delete the token from LocalStorage.
    """
    try:
        supabase.auth.sign_out()
        return None
    except Exception as e:
        # Even if it fails, we return 204 because the user wants to leave.
        return None
    
@app.get("/student/my-profile")
def read_my_student_profile(
    user_id: str = Depends(get_current_user_id), 
    db: Session = Depends(get_db)
):
    
    student_data = db.query(Student).filter(Student.studentID == user_id).first()
    return student_data

@app.get("/lecturer/my-profile")
def read_my_student_profile(
    user_id: str = Depends(get_current_user_id), 
    db: Session = Depends(get_db)
):
    
    lecturer_data = db.query(Lecturer).filter(Lecturer.lecturerID == user_id).first()
    return lecturer_data

@app.get("/admin/my-profile")
def read_my_student_profile(
    user_id: str = Depends(get_current_user_id), 
    db: Session = Depends(get_db)
):
    
    admin_data = db.query(Admin).filter(Admin.adminID == user_id).first()
    return admin_data

#Important to keep this
app.include_router(studentDashboardRouter.router, tags=['student'])
app.include_router(adminDashboardRouter.router, tags=['admin'])
app.include_router(lecturerDashboardRouter.router, tags=['lecturer'])