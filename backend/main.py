from typing import Union, List
from fastapi import FastAPI, Depends, HTTPException, status, APIRouter
from sqlalchemy import func, distinct, case, literal, and_
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials   
from pydantic import BaseModel
from sqlalchemy import create_engine, text
from sqlalchemy.orm import sessionmaker, Session
from database.db_config import get_db #Gets the Initialized db session
from database.db import UserProfile, User, Admin, Lecturer, Student, Lesson, EntLeave, Module, AttdCheck, StudentModules, studentAngles, Courses, LecMod
from uuid import UUID
from pdantic.schemas import UserSignUp, UserLogin, TokenResponse, timetableEntry, AttendanceOverviewCard , RecentSessionsCardData, LecturerDashboardSummary
from dependencies.deps import get_current_user_id
from client import supabase, supabase_adm
import datetime
from routers import studentDashboardRouter

app = FastAPI()
security = HTTPBearer()


origins = [
    "http://localhost:3000",  # React Create App
]

app.add_middleware(
    CORSMiddleware,
    allow_origins= origins,
    allow_credentials = True,
    allow_methods=["*"],
    allow_headers=["*"]
)


@app.get("/")
def read_root(db: Session= Depends(get_db)):
    response = (supabase_adm.table("users").select("*").execute())
    return {"Message": response}

@app.post("/createAcc", status_code=status.HTTP_201_CREATED)
def register_user(user: UserSignUp, db: Session = Depends(get_db)):
    # ==========================================
    # STEP 1: Create User in Supabase Auth
    # ==========================================
    try:
        # This contacts Supabase Cloud to create the login
        auth_response = supabase_adm.auth.admin.create_user({
            "email": user.email,
            "password": user.password,
            # Optional: Add metadata so it lives in the JWT
            "options": {
                "data": {
                    "name": user.name,
                    "role": user.role
                }
            }
        })
        
        if not auth_response.user:
            raise HTTPException(status_code=400, detail="Signup failed (User already exists?)")
            
        # Capture the UUID generated by Supabase
        new_uuid = UUID(auth_response.user.id)

    except Exception as e:
        # Catch Supabase errors (like "Password too short" or "Email exists")
        raise HTTPException(status_code=400, detail=str(e))

    # ==========================================
    # STEP 2: Create Profile in Postgres
    # ==========================================
    try:
        new_db_user = None

        if user.role.lower() == "student":
            # Ensure course_id is provided for students
            if not user.course_id:
                raise HTTPException(status_code=400, detail="Student requires a course_id")

            new_db_user = Student(
                userID=new_uuid,  # LINKING THE UUID
                name=user.name,
                email=user.email,
                profileTypeID=user.profile_type_id,
                courseID=user.course_id,
                # Default values
                photo=None
            )
            
        elif user.role.lower() == "lecturer":
            new_db_user = Lecturer(
                userID=new_uuid, # <--- LINKING THE UUID
                name=user.name,
                email=user.email,
                profileTypeID=user.profile_type_id,
                photo=None
            )
        else:
            # If role is invalid, we have a problem. 
            # We created an Auth User but can't create a DB Profile.
            # We should technically delete the Auth User here to clean up.
            raise HTTPException(status_code=400, detail="Invalid Role")

        # Save to Database
        db.add(new_db_user)
        db.commit()
        db.refresh(new_db_user)

        return {"message": "User created successfully", "user_id": new_uuid}

    except Exception as e:
        # CRITICAL: If DB insert fails (e.g. Course ID doesn't exist), 
        # we have a "Ghost User" in Supabase Auth but no profile in DB.
        db.rollback()
        
        # Cleanup: Delete the Auth user so they can try again
        # Note: Requires Service Role Key to delete. If using Anon key, you can't cleanup easily.
        print(f"Database error: {e}") 
        raise HTTPException(status_code=500, detail="Profile creation failed. Please contact support.")
# @router.delete("/users/{user_id}", status_code=status.HTTP_204_NO_CONTENT)

@app.delete("/delacc/{user_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_user(user_id: UUID, db: Session = Depends(get_db)):
    
    # ==========================================
    # STEP 1: Check if user exists in Public DB
    # ==========================================
    # We query the Base 'User' table because it covers Students, Lecturers, etc.
    user_to_delete = db.query(User).filter(User.userID == user_id).first()
    
    if not user_to_delete:
        raise HTTPException(status_code=404, detail="User not found in database")

    # ==========================================
    # STEP 2: Delete from Public Database (SQLAlchemy)
    # ==========================================
    try:
        db.delete(user_to_delete)
        db.commit()
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Failed to delete profile: {str(e)}")

    # ==========================================
    # STEP 3: Delete from Supabase Auth (Cloud)
    # ==========================================
    try:
        # returns an object with 'data' and 'error' (in older versions) 
        # or simply returns None/Data (in newer versions)
        response = supabase_adm.auth.admin.delete_user(str(user_id))
        
        # Note: If the user didn't exist in Auth (ghost user), this might throw an error 
        # or just work silently. We generally assume success if no exception raised.
        
    except Exception as e:
        # If Auth deletion fails, we have a problem: 
        # The profile is gone from DB, but the login remains.
        # Ideally, you should log this error heavily.
        print(f"CRITICAL: Profile deleted but Auth User {user_id} remains! Error: {e}")
        raise HTTPException(status_code=500, detail="Profile deleted, but Auth account cleanup failed.")

    return None


@app.post("/login", response_model = TokenResponse)
def login(credentials:UserLogin, db:Session = Depends(get_db)):
    try:
        # This sends email/password to Supabase. 
        # If valid, Supabase returns a Session object with tokens.
        auth_response = supabase.auth.sign_in_with_password({
            "email": credentials.email,
            "password": credentials.password
        })
        session = auth_response.session
        user = auth_response.user
        
        if not session or not user:
             raise HTTPException(status_code=401, detail="Invalid credentials")
    except Exception as e:
        # Supabase throws an exception if password is wrong or email not confirmed
        raise HTTPException(status_code=401, detail=str(e))
    # -------------------------------------------------------
    # STEP 2: Identify Role from Postgres DB
    # -------------------------------------------------------
    # We have the UUID from Supabase. Now let's see who they are in our DB.
    
    user_uuid = user.id
    
    # Query the 'users' table to get the profileTypeID
    db_user = db.query(User).filter(User.userID == user_uuid).first()
    
    if not db_user:
        # This happens if they exist in Auth but were deleted from DB (Ghost User)
        raise HTTPException(status_code=404, detail="User profile not found in database.")

    # Optional: Fetch the text name of the role (e.g., "Student")
    # This requires a join or a separate query if lazy loading isn't set up
    role_name = "Unknown"
    profile_type = db.query(UserProfile).filter(UserProfile.profileTypeID == db_user.profileTypeID).first()
    if profile_type:
        role_name = profile_type.profileTypeName

    # -------------------------------------------------------
    # STEP 3: Return the Bundle
    # -------------------------------------------------------
    return {
        "access_token": session.access_token,
        "refresh_token": session.refresh_token,
        "token_type": "bearer",
        "user_id": user_uuid,
        "role_id": db_user.profileTypeID,
        "role_name": role_name
    }

@app.post("/logout", status_code=204)
def logout():
    """
    Logs out the user on the server side (invalidates refresh token).
    The Frontend MUST also delete the token from LocalStorage.
    """
    try:
        supabase.auth.sign_out()
        return None
    except Exception as e:
        # Even if it fails, we return 204 because the user wants to leave.
        return None
    
@app.get("/my-profile")
def read_my_student_profile(
    user_id: str = Depends(get_current_user_id), 
    db: Session = Depends(get_db)
):
    # If the code reaches here, the token is valid.
    # We also know the user_id (UUID).
    
    # We can safely query data specifically for this user
    student_data = db.query(Student).filter(Student.studentID == user_id).first()
    # lesson_data = db.query(Lesson).join()
    # attendance_data = db.query()
    return student_data

#---------------------------#
# LECTURER DASHBOARD ROUTES
#---------------------------#

# total module taught by me
@app.get("/lecturer/dashboard/summary")
def get_lecturer_dashboard_summary(
    user_id: str = Depends(get_current_user_id),
    db: Session = Depends(get_db)
):
    mods_taught_by_me = db.query(LecMod).filter(LecMod.lecturerID == user_id).all()
    return {"total_modules": len(mods_taught_by_me)}

# # total number of Attendance Records and Report
# @app.get("/lecturer/dashboard/recent-sessions-card", response_model=RecentSessionsCardData)
# def get_recent_sessions_card(
#     user_id: str = Depends(get_current_user_id),
#     db: Session = Depends(get_db)
# ):
#     """
#     Counts the total number of lessons that have been completed 
#     by this lecturer.
#     """
    
#     # 1. Get current time
#     now = datetime.datetime.now()

#     # 2. Query Logic:
#     # - Join Lesson and LecMod
#     # - Filter by the logged-in Lecturer (user_id)
#     # - Filter for lessons that have already ended (endDateTime < now)
#     recent_sessions_count = db.query(func.count(Lesson.lessonID))\
#         .join(LecMod, Lesson.lecModID == LecMod.lecModID)\
#         .filter(
#             LecMod.lecturerID == user_id,
#             Lesson.endDateTime < now
#         ).scalar() or 0

#     # Optional: If you strictly mean "Recent" (e.g., last 7 days only), 
#     # add this line to the filter above:
#     # Lesson.endDateTime >= (now - datetime.timedelta(days=7))

#     # 3. Return Data
#     return RecentSessionsCardData(
#         Recent_sessions_record=recent_sessions_count,
#         label="Recent sessions recorded"
#     )

# Timetable for dashboard
@app.get("/lecturer/dashboard/timetable", response_model=list[timetableEntry])
def get_lecturer_timetable(
    user_id: str = Depends(get_current_user_id),
    db: Session = Depends(get_db)
):
    now = datetime.datetime.now()
    next_week = now + datetime.timedelta(days=7)

    upcoming_lessons = db.query(Lesson, Module)\
        .join(LecMod, Lesson.lecModID == LecMod.lecModID)\
        .join(Module, LecMod.moduleID == Module.moduleID)\
        .filter(
            LecMod.lecturerID == user_id,
            Lesson.startDateTime >= now,
            Lesson.startDateTime <= next_week
        )\
        .order_by(Lesson.startDateTime)\
        .all()

    results = []
    for lesson, module in upcoming_lessons:
        
        # 1. Handle Location (Combine Building + Room)
        bldg = lesson.building or ""
        rm = lesson.room or ""
        
        if bldg and rm:
            loc_str = f"{bldg}-{rm}"
        else:
            loc_str = bldg + rm 
            
        if not loc_str:
            loc_str = "Online"

        # 2. Create the Pydantic Object
        entry = timetableEntry(
            module_code=module.moduleCode,
            day_of_week=lesson.startDateTime.strftime("%a"),
            start_time=lesson.startDateTime.strftime("%I:%M %p").lstrip("0"),
            end_time=lesson.endDateTime.strftime("%I:%M %p").lstrip("0"),
            location=loc_str
        )
        results.append(entry)

    return results

# Average Attendance across all modules taught by me
@app.get("/lecturer/dashboard/average-attendance", response_model=AttendanceOverviewCard)
def get_lecturer_average_attendance_safe(
    user_id: str = Depends(get_current_user_id),
    db: Session = Depends(get_db)
):
    lec_mods = db.query(LecMod).filter(LecMod.lecturerID == user_id).all()

    total_capacity = 0
    total_actual_checkins = 0

    for lm in lec_mods:
        # 1. Get Official Count
        enrolled_count = db.query(StudentModules).filter(
            StudentModules.modulesID == lm.moduleID
        ).count()

        # 2. Get Count of distinct people who have EVER attended this module
        # (This catches students missing from the StudentModules table)
        active_students = db.query(AttdCheck.studentID)\
            .join(Lesson).filter(Lesson.lecModID == lm.lecModID)\
            .distinct().count()

        # 3. SAFETY CHECK: Use the higher number
        # If DB says 1 student, but 4 people are attending, we use 4 to prevent >100%
        real_student_count = max(enrolled_count, active_students)

        # 4. Get Lessons
        lesson_count = db.query(Lesson).filter(
            Lesson.lecModID == lm.lecModID,
            Lesson.endDateTime < datetime.datetime.now()
        ).count()

        # 5. Math
        total_capacity += (real_student_count * lesson_count)

        unique_checkins = db.query(AttdCheck.lessonID, AttdCheck.studentID)\
            .join(Lesson).filter(
                Lesson.lecModID == lm.lecModID,
                Lesson.endDateTime < datetime.datetime.now()
            )\
            .distinct().count()
            
        total_actual_checkins += unique_checkins

    # Result
    if total_capacity == 0:
        percentage = 0.0
    else:
        percentage = (total_actual_checkins / total_capacity) * 100.0

    return AttendanceOverviewCard(
        Average_attendance=round(percentage, 1), 
        label="Across all courses"
    )

# Recent Sessions recorded
@app.get("/lecturer/dashboard/recent-sessions-card", response_model=RecentSessionsCardData)
def get_recent_sessions_card(
    user_id: str = Depends(get_current_user_id),
    db: Session = Depends(get_db)
):
    """
    Counts the total number of unique lessons that have been completed 
    by this lecturer in the last 7 days.
    """
    
    # Define the time window (Last 7 Days)
    now = datetime.datetime.now()
    seven_days_ago = now - datetime.timedelta(days=7)

    # Query Logic: Count the unique Lesson IDs
    recent_sessions_count = db.query(func.count(Lesson.lessonID))\
        .join(LecMod, Lesson.lecModID == LecMod.lecModID)\
        .filter(
            LecMod.lecturerID == user_id,
            Lesson.endDateTime < now,           # Class is finished
            Lesson.endDateTime >= seven_days_ago # Finished recently
        ).scalar() or 0

    # Return Data
    return RecentSessionsCardData(
        Recent_sessions_record=recent_sessions_count, 
        label="Recent sessions recorded"
    )

app.include_router(studentDashboardRouter.router, tags=["Student"])
